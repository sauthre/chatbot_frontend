<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="supabase.js"></script>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flarefix — Secret Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="supabase.js"></script>

  <style>
    /* small tweaks for message bubble shapes */
    .bubble { border-radius: 12px; padding: 10px; box-shadow: 0 1px 1px rgba(0,0,0,0.06); }
    .bubble-right { border-bottom-right-radius: 4px; }
    .bubble-left  { border-bottom-left-radius: 4px; }
    #thread { scroll-behavior: smooth; }
  </style>
</head>
<body class="bg-gray-50 text-gray-900 h-screen flex flex-col">

  <header class="px-4 py-3 border-b bg-white sticky top-0 z-10 flex items-center justify-between">
    <div class="flex items-center gap-3">
      <button id="backBtn" class="text-sm px-3 py-1 rounded bg-gray-200">← Back</button>
      <div>
        <div id="roomLabel" class="font-semibold text-sm">Room</div>
        <div id="userLabel" class="text-xs text-gray-500">You</div>
      </div>
    </div>
    <div class="text-xs text-gray-500">Flarefix</div>
  </header>

  <main id="messages" class="flex-1 overflow-y-auto p-3">
    <div id="thread" class="max-w-3xl mx-auto space-y-3"></div>
  </main>

  <footer class="p-3 bg-white border-t">
    <div class="max-w-3xl mx-auto flex gap-2">
      <input id="msg" placeholder="Message..." class="flex-1 border rounded-xl px-3 py-2 outline-none" />
      <button id="sendBtn" class="px-4 py-2 bg-black text-white rounded-xl">Send</button>
    </div>
  </footer>

<script>
/* ---------- config & state ---------- */
const params = new URLSearchParams(window.location.search);
const roomId = params.get('room') || 'public';
const username = params.get('user') || 'Anonymous';
const dbClient = window.db;
const threadEl = document.getElementById('thread');
const msgInput = document.getElementById('msg');
const sendBtn = document.getElementById('sendBtn');
const roomLabel = document.getElementById('roomLabel');
const userLabel = document.getElementById('userLabel');
const backBtn = document.getElementById('backBtn');

roomLabel.textContent = `Room: ${roomId}`;
userLabel.textContent = `You: ${username}`;

backBtn.addEventListener('click', () => window.history.back());

let messagesCache = []; // holds messages shown in UI (latest last)

/* ---------- helpers ---------- */
function renderMessages(list) {
  threadEl.innerHTML = '';
  list.forEach(m => {
    const mine = m.username === username;
    const wrapper = document.createElement('div');
    wrapper.className = `w-full flex ${mine ? 'justify-end' : 'justify-start'}`;

    const bubble = document.createElement('div');
    bubble.className = `bubble ${mine ? 'bubble-right bg-green-500 text-white' : 'bubble-left bg-white text-black border'}`;
    bubble.style.maxWidth = '70%';
    bubble.innerHTML = `<div class="text-xs opacity-80 mb-1">${escapeHtml(m.username)}</div><div class="whitespace-pre-wrap">${escapeHtml(m.text)}</div>
      <div class="text-[10px] mt-1 text-right opacity-60">${new Date(m.created_at).toLocaleTimeString()}</div>`;

    wrapper.appendChild(bubble);
    threadEl.appendChild(wrapper);
  });

  // auto scroll to bottom
  threadEl.parentElement.scrollTop = threadEl.parentElement.scrollHeight;
}

function escapeHtml(s){
  return String(s || '').replace(/[&<>"']/g, c => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
  })[c]);
}

/* ---------- load existing messages (latest 200) ---------- */
async function loadInitialMessages() {
  try {
    const { data, error } = await dbClient
      .from('messages')
      .select('*')
      .eq('room_id', roomId)
      .order('created_at', { ascending: true })
      .limit(200); // load max 200 newest (ascending -> oldest->newest)
    if (error) throw error;
    messagesCache = data || [];
    renderMessages(messagesCache);
  } catch (err) {
    console.error('loadInitialMessages', err);
  }
}

/* ---------- cleanup function: keep only latest 200 messages per room ---------- */
async function cleanupOldMessages() {
  try {
    // fetch ids ordered newest->oldest
    const { data, error } = await dbClient
      .from('messages')
      .select('id, created_at')
      .eq('room_id', roomId)
      .order('created_at', { ascending: false }); // newest first

    if (error) throw error;
    if (!data || data.length <= 200) return;

    const idsToDelete = data.slice(200).map(r => r.id);
    if (idsToDelete.length === 0) return;

    const { error: delError } = await dbClient
      .from('messages')
      .delete()
      .in('id', idsToDelete);

    if (delError) console.error('cleanup delete error', delError);
  } catch (err) {
    console.error('cleanupOldMessages', err);
  }
}

/* ---------- send message ---------- */
async function sendMessage() {
  const text = msgInput.value.trim();
  if (!text) return;
  sendBtn.disabled = true;
  msgInput.value = '';

  try {
    const { error: insErr } = await dbClient.from('messages').insert([{
      room_id: roomId,
      username,
      text,
      created_at: new Date().toISOString()
    }]);

    if (insErr) throw insErr;

    // cleanup old messages (async)
    cleanupOldMessages().catch(e => console.error(e));
  } catch (err) {
    console.error('sendMessage error', err);
    alert('Error sending message: ' + (err.message || err));
  } finally {
    sendBtn.disabled = false;
    msgInput.focus();
  }
}

/* ---------- realtime listener for this room only ---------- */
function subscribeRealtime() {
  try {
    dbClient.channel(`room_${roomId}`)
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'messages',
        filter: `room_id=eq.${roomId}`
      }, payload => {
        if (payload && payload.new) {
          // append to cache and keep length <= 200 client-side
          messagesCache.push(payload.new);
          if (messagesCache.length > 200) messagesCache = messagesCache.slice(messagesCache.length - 200);
          renderMessages(messagesCache);
        }
      })
      .subscribe();
  } catch (err) {
    console.error('subscribeRealtime', err);
  }
}

/* ---------- UI events ---------- */
sendBtn.addEventListener('click', sendMessage);
msgInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendMessage();
  }
});

/* ---------- init ---------- */
loadInitialMessages();
subscribeRealtime();
</script>

</body>
</html>
