<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Secret Chat ‚Äî Flarefix</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="supabase.js"></script>

  <style>
    .bubble { border-radius: 12px; padding: 10px; box-shadow: 0 1px 1px rgba(0,0,0,0.06); }
    .bubble-right { border-bottom-right-radius: 4px; }
    .bubble-left  { border-bottom-left-radius: 4px; }
    #thread { scroll-behavior: smooth; }
    .image-msg { max-width: 60%; border-radius: 12px; display:block; }
  </style>
</head>

<body class="bg-gray-50 text-gray-900 h-screen flex flex-col">

  <!-- HEADER -->
  <header class="px-4 py-3 border-b bg-white sticky top-0 z-10 flex items-center justify-between">
    <div class="flex items-center gap-3">
      <button id="backBtn" class="text-sm px-3 py-1 rounded bg-gray-200">‚Üê Back</button>
      <div>
        <div id="roomLabel" class="font-semibold text-sm">Room</div>
        <div id="userLabel" class="text-xs text-gray-500">You</div>
      </div>
    </div>

    <div class="flex items-center gap-3">
      <div id="typingEl" class="text-sm text-gray-500 hidden"></div>

      <button id="deleteRoomBtn" class="text-red-500 text-sm">Delete Room</button>

      <!-- Image Upload UI -->
      <label id="attachBtn" for="imageInput"
        class="cursor-pointer px-3 py-1 bg-gray-200 rounded text-xl hover:bg-gray-300">
        üìé
      </label>
      <input id="imageInput" type="file" accept="image/*" class="hidden" />
    </div>
  </header>

  <!-- CHAT THREAD -->
  <main id="messages" class="flex-1 overflow-y-auto p-3">
    <div id="thread" class="max-w-3xl mx-auto space-y-3"></div>
  </main>

  <!-- FOOTER -->
  <footer class="p-3 bg-white border-t">
    <div class="max-w-3xl mx-auto flex gap-2 items-center">
      <label for="imageInput"
        class="cursor-pointer w-10 h-10 grid place-items-center bg-gray-200 rounded-full text-xl hover:bg-gray-300 active:scale-95">
        üìé
      </label>

      <textarea id="msg" rows="1" placeholder="Message..."
        class="flex-1 border rounded-xl px-3 py-2 outline-none resize-none"></textarea>

      <button id="sendBtn" class="px-4 py-2 bg-black text-white rounded-xl">Send</button>
    </div>
  </footer>

  <!-- IMAGE PREVIEW MODAL -->
  <div id="imagePreviewModal" class="fixed inset-0 bg-black/50 hidden items-center justify-center z-50">
    <div class="bg-white rounded-lg p-3 max-w-xl w-[90%]">
      <div class="flex items-center justify-between mb-2">
        <div class="font-medium">Preview Image</div>
        <div>
          <button id="cancelImage" class="mr-2 text-sm text-gray-600">Cancel</button>
          <button id="confirmImage" class="px-3 py-1 bg-black text-white rounded">Send</button>
        </div>
      </div>
      <div class="flex items-center justify-center">
        <img id="imagePreview" src="" class="max-h-[60vh] rounded">
      </div>
      <div id="uploadStatus" class="text-sm mt-2 text-center text-gray-600"></div>
    </div>
  </div>


<script>
/* -------------------------------------
   Setup
-------------------------------------- */
const params = new URLSearchParams(window.location.search);
const roomId = params.get('room') || 'public';
const username = params.get('user') || 'Anonymous';
const dbClient = window.db;

const threadEl = document.getElementById('thread');
const msgInput = document.getElementById('msg');
const sendBtn = document.getElementById('sendBtn');
const imageInputEl = document.getElementById('imageInput');
const typingEl = document.getElementById('typingEl');
const deleteRoomBtn = document.getElementById('deleteRoomBtn');
const backBtn = document.getElementById('backBtn');

document.getElementById('roomLabel').textContent = `Room: ${roomId}`;
document.getElementById('userLabel').textContent = `You: ${username}`;

let messagesCache = [];

/* -------------------------------------
   Helper: escape HTML
-------------------------------------- */
function escapeHtml(s) {
  return String(s || '').replace(/[&<>"']/g, (c)=>({
    '&':'&amp;', '<':'&lt;', '>':'&gt;',
    '"':'&quot;', "'":'&#39;'
  })[c]);
}

/* -------------------------------------
   Render Messages
-------------------------------------- */
function renderMessages(list) {
  threadEl.innerHTML = '';

  list.forEach((m) => {
    const mine = m.username === username;
    const wrap = document.createElement('div');
    wrap.className = `w-full flex ${mine ? 'justify-end' : 'justify-start'}`;

    const bubble = document.createElement('div');
    bubble.className = `bubble ${
      mine ? 'bubble-right bg-green-500 text-white' : 'bubble-left bg-white text-black border'
    }`;
    bubble.style.maxWidth = '70%';

    let content = m.image_url
      ? `<img src="${escapeHtml(m.image_url)}" class="image-msg">`
      : `<div class="whitespace-pre-wrap">${escapeHtml(m.text)}</div>`;

    bubble.innerHTML = `
      <div class="text-xs opacity-80 mb-1">${escapeHtml(m.username)}</div>
      ${content}
      <div class="text-[10px] mt-1 text-right opacity-60">${new Date(m.created_at).toLocaleTimeString()}</div>
    `;

    wrap.appendChild(bubble);
    threadEl.appendChild(wrap);
  });

  threadEl.parentElement.scrollTop = threadEl.parentElement.scrollHeight;
}

/* -------------------------------------
   Load Initial Messages
-------------------------------------- */
async function loadInitialMessages() {
  const { data } = await dbClient
    .from('messages')
    .select('*')
    .eq('room_id', roomId)
    .order('created_at', { ascending: true })
    .limit(200);

  messagesCache = data || [];
  renderMessages(messagesCache);
}

/* -------------------------------------
   Cleanup old messages (keep only 200)
-------------------------------------- */
async function cleanupOldMessages() {
  const { data } = await dbClient
    .from('messages')
    .select('id, created_at')
    .eq('room_id', roomId)
    .order('created_at', { ascending: false });

  if (!data || data.length <= 200) return;

  const idsToDelete = data.slice(200).map((m) => m.id);
  await dbClient.from('messages').delete().in('id', idsToDelete);
}

/* -------------------------------------
   Send text message
-------------------------------------- */
async function sendMessage() {
  const text = msgInput.value.trim();
  if (!text) return;

  msgInput.value = '';
  sendBtn.disabled = true;

  await dbClient.from('messages').insert([
    {
      room_id: roomId,
      username,
      text,
      created_at: new Date().toISOString(),
    },
  ]);

  sendBtn.disabled = false;
  await cleanupOldMessages();
}

/* -------------------------------------
   IMAGE UPLOAD SYSTEM
-------------------------------------- */
const imagePreviewModal = document.getElementById('imagePreviewModal');
const imagePreview = document.getElementById('imagePreview');
const uploadStatus = document.getElementById('uploadStatus');
const cancelImageBtn = document.getElementById('cancelImage');
const confirmImageBtn = document.getElementById('confirmImage');
const MAX_FILE_SIZE = 5 * 1024 * 1024;

// compress image if large
async function compressImage(file, maxWidth = 1280, quality = 0.8) {
  return new Promise((resolve, reject) => {
    try {
      const img = new Image();
      const reader = new FileReader();
      reader.onload = (e) => {
        img.onload = () => {
          let { width, height } = img;
          if (width > maxWidth) {
            const ratio = maxWidth / width;
            width = Math.round(width * ratio);
            height = Math.round(height * ratio);
          }
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, width, height);
          canvas.toBlob((blob) => blob ? resolve(blob) : reject('Compression failed'),
            'image/jpeg', quality
          );
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    } catch (err) { reject(err); }
  });
}

// open preview modal
imageInputEl.addEventListener('change', () => {
  const file = imageInputEl.files[0];
  if (!file) return;

  const url = URL.createObjectURL(file);
  imagePreview.src = url;
  imagePreviewModal.classList.remove('hidden');
  imageInputEl._selectedFile = file;
});

// cancel image modal
cancelImageBtn.addEventListener('click', () => {
  imagePreviewModal.classList.add('hidden');
  imagePreview.src = '';
  imageInputEl.value = '';
  imageInputEl._selectedFile = null;
});

// confirm upload
confirmImageBtn.addEventListener('click', async () => {
  const file = imageInputEl._selectedFile;
  if (!file) return;

  try {
    confirmImageBtn.disabled = true;
    cancelImageBtn.disabled = true;
    uploadStatus.textContent = 'Compressing...';

    let blob = file;
    if (file.size > 1 * 1024 * 1024) {
      blob = await compressImage(file);
    }

    if (blob.size > MAX_FILE_SIZE) {
      uploadStatus.textContent = 'File too large after compression!';
      return;
    }

    uploadStatus.textContent = 'Uploading...';

    const filename = `${Date.now()}_${Math.random().toString(36).slice(2,8)}.jpg`;
    const filePath = `${roomId}/${filename}`;

    const uploadRes = await dbClient.storage
      .from('chat-images')
      .upload(filePath, blob);

    if (uploadRes.error) throw uploadRes.error;

    const { data } = dbClient.storage
      .from('chat-images')
      .getPublicUrl(filePath);

    await dbClient.from('messages').insert([{
      room_id: roomId,
      username,
      text: '',
      image_url: data.publicUrl,
      created_at: new Date().toISOString()
    }]);

    uploadStatus.textContent = 'Sent!';

    setTimeout(() => {
      imagePreviewModal.classList.add('hidden');
      imagePreview.src = '';
      imageInputEl.value = '';
      imageInputEl._selectedFile = null;
      uploadStatus.textContent = '';
      confirmImageBtn.disabled = false;
      cancelImageBtn.disabled = false;
    }, 500);

    await cleanupOldMessages();

  } catch (err) {
    uploadStatus.textContent = 'Upload failed: ' + err.message;
  }
});

/* -------------------------------------
   DELETE ROOM + IMAGES (final fix)
-------------------------------------- */
deleteRoomBtn.addEventListener('click', async () => {
  if (!confirm('Delete this room including ALL images?')) return;

  try {
    // 1) List all images in bucket folder = roomId
    const { data: files } = await dbClient.storage
      .from('chat-images')
      .list(roomId, { limit: 1000 });

    // 2) Delete them if exist
    if (files && files.length > 0) {
      const paths = files.map(f => `${roomId}/${f.name}`);
      await dbClient.storage.from('chat-images').remove(paths);
    }

    // 3) Delete all messages
    await dbClient.from('messages').delete().eq('room_id', roomId);

    // 4) Delete room entry
    await dbClient.from('rooms').delete().eq('room_id', roomId);

    alert('Room and all images deleted.');
    window.location.href = "home.html";

  } catch (err) {
    alert("Delete failed: " + err.message);
  }
});

/* -------------------------------------
   REALTIME ‚Äî MESSAGES
-------------------------------------- */
function subscribeRealtime() {
  const msgChannel = dbClient.channel(`messages:${roomId}`);

  msgChannel.on(
    'postgres_changes',
    { event: 'INSERT', schema: 'public', table: 'messages', filter: `room_id=eq.${roomId}` },
    (payload) => {
      messagesCache.push(payload.new);
      if (messagesCache.length > 200)
        messagesCache = messagesCache.slice(-200);
      renderMessages(messagesCache);
    }
  );

  msgChannel.subscribe();
}

/* -------------------------------------
   INIT
-------------------------------------- */
sendBtn.addEventListener('click', sendMessage);

msgInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendMessage();
  }
});

backBtn.addEventListener('click', () => window.history.back());

loadInitialMessages();
subscribeRealtime();
</script>

</body>
</html>
