<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Secret Chat ‚Äî Flarefix</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="supabase.js"></script>

  <style>
    .bubble { border-radius: 12px; padding: 10px; box-shadow: 0 1px 1px rgba(0,0,0,0.06); }
    .bubble-right { border-bottom-right-radius: 4px; }
    .bubble-left  { border-bottom-left-radius: 4px; }
    #thread { scroll-behavior: smooth; }
    .image-msg { max-width: 60%; border-radius: 12px; display:block; }
  </style>
</head>

<body class="bg-gray-50 text-gray-900 h-screen flex flex-col">

  <!-- HEADER -->
  <header class="px-4 py-3 border-b bg-white sticky top-0 z-10 flex items-center justify-between">
    <div class="flex items-center gap-3">
      <button id="backBtn" class="text-sm px-3 py-1 rounded bg-gray-200">‚Üê Back</button>
      <div>
        <div id="roomLabel" class="font-semibold text-sm">Room</div>
        <div id="userLabel" class="text-xs text-gray-500">You</div>
      </div>
    </div>

    <div class="flex items-center gap-3">
      <div id="typingEl" class="text-sm text-gray-500 hidden"></div>
      <button id="deleteRoomBtn" class="text-red-500 text-sm">Delete Room</button>

      <label for="imageInput" class="cursor-pointer px-3 py-1 bg-gray-200 rounded">üìé</label>
      <input id="imageInput" type="file" accept="image/*" class="hidden" />
    </div>
  </header>

  <!-- CHAT THREAD -->
  <main id="messages" class="flex-1 overflow-y-auto p-3">
    <div id="thread" class="max-w-3xl mx-auto space-y-3"></div>
  </main>

  <!-- FOOTER -->
  <footer class="p-3 bg-white border-t">
    <div class="max-w-3xl mx-auto flex gap-2 items-center">
      <textarea id="msg" rows="1" placeholder="Message..." class="flex-1 border rounded-xl px-3 py-2 outline-none resize-none"></textarea>
      <button id="sendBtn" class="px-4 py-2 bg-black text-white rounded-xl">Send</button>
    </div>
  </footer>

<script>
/* -------------------------------------
   Setup
-------------------------------------- */
const params = new URLSearchParams(window.location.search);
const roomId = params.get('room') || 'public';
const username = params.get('user') || 'Anonymous';
const dbClient = window.db;

const threadEl = document.getElementById('thread');
const msgInput = document.getElementById('msg');
const sendBtn = document.getElementById('sendBtn');
const typingEl = document.getElementById('typingEl');
const deleteRoomBtn = document.getElementById('deleteRoomBtn');
const imageInput = document.getElementById('imageInput');
const backBtn = document.getElementById('backBtn');

document.getElementById('roomLabel').textContent = `Room: ${roomId}`;
document.getElementById('userLabel').textContent = `You: ${username}`;

let messagesCache = [];
let typingTimeout;

/* Sanitize text */
function escapeHtml(s) {
  return String(s || '').replace(/[&<>"']/g, (c)=>({
    '&':'&amp;', '<':'&lt;', '>':'&gt;',
    '"':'&quot;', "'":'&#39;'
  })[c]);
}

/* -------------------------------------
   Render Messages
-------------------------------------- */
function renderMessages(list) {
  threadEl.innerHTML = '';

  list.forEach((m) => {
    const mine = m.username === username;
    const wrap = document.createElement('div');
    wrap.className = `w-full flex ${mine ? 'justify-end' : 'justify-start'}`;

    const bubble = document.createElement('div');
    bubble.className = `bubble ${
      mine ? 'bubble-right bg-green-500 text-white' : 'bubble-left bg-white text-black border'
    }`;
    bubble.style.maxWidth = '70%';

    let content = m.image_url
      ? `<img src="${escapeHtml(m.image_url)}" class="image-msg">`
      : `<div class="whitespace-pre-wrap">${escapeHtml(m.text)}</div>`;

    bubble.innerHTML = `
      <div class="text-xs opacity-80 mb-1">${escapeHtml(m.username)}</div>
      ${content}
      <div class="text-[10px] mt-1 text-right opacity-60">${new Date(m.created_at).toLocaleTimeString()}</div>
    `;

    wrap.appendChild(bubble);
    threadEl.appendChild(wrap);
  });

  threadEl.parentElement.scrollTop = threadEl.parentElement.scrollHeight;
}

/* -------------------------------------
   Initial Load
-------------------------------------- */
async function loadInitialMessages() {
  const { data } = await dbClient
    .from('messages')
    .select('*')
    .eq('room_id', roomId)
    .order('created_at', { ascending: true })
    .limit(200);

  messagesCache = data || [];
  renderMessages(messagesCache);
}

/* -------------------------------------
   Cleanup (last 200)
-------------------------------------- */
async function cleanupOldMessages() {
  const { data } = await dbClient
    .from('messages')
    .select('id, created_at')
    .eq('room_id', roomId)
    .order('created_at', { ascending: false });

  if (!data || data.length <= 200) return;

  const idsToDelete = data.slice(200).map((m) => m.id);

  await dbClient.from('messages').delete().in('id', idsToDelete);
}

/* -------------------------------------
   Send Message
-------------------------------------- */
async function sendMessage() {
  const text = msgInput.value.trim();
  if (!text) return;

  msgInput.value = '';
  sendBtn.disabled = true;

  await dbClient.from('messages').insert([
    {
      room_id: roomId,
      username,
      text,
      created_at: new Date().toISOString(),
    },
  ]);

  await cleanupOldMessages();

  await dbClient.from('typing_status').upsert({
    room_id: roomId,
    username,
    typing: false,
    updated_at: new Date().toISOString(),
  });

  sendBtn.disabled = false;
}

/* -------------------------------------
   Image Upload
-------------------------------------- */
imageInput.addEventListener('change', async () => {
  const file = imageInput.files[0];
  if (!file) return;

  const filePath = `${roomId}/${Date.now()}_${file.name}`;

  const upload = await dbClient.storage
    .from('chat-images')
    .upload(filePath, file);

  const { data } = dbClient.storage
    .from('chat-images')
    .getPublicUrl(filePath);

  await dbClient.from('messages').insert([
    {
      room_id: roomId,
      username,
      text: '',
      image_url: data.publicUrl,
      created_at: new Date().toISOString(),
    },
  ]);

  await cleanupOldMessages();

  imageInput.value = '';
});

/* -------------------------------------
   Delete Room
-------------------------------------- */
deleteRoomBtn.addEventListener('click', async () => {
  if (!confirm('Delete this room?')) return;

  await dbClient.from('messages').delete().eq('room_id', roomId);
  await dbClient.from('rooms').delete().eq('room_id', roomId);

  alert('Room deleted');
  window.location.href = 'home.html';
});

/* -------------------------------------
   Typing Indicator (Fixed)
-------------------------------------- */
msgInput.addEventListener('input', async () => {
  await dbClient.from('typing_status').upsert({
    room_id: roomId,
    username,
    typing: true,
    updated_at: new Date().toISOString(),
  });

  clearTimeout(typingTimeout);

  typingTimeout = setTimeout(async () => {
    await dbClient.from('typing_status').upsert({
      room_id: roomId,
      username,
      typing: false,
      updated_at: new Date().toISOString(),
    });
  }, 1200);
});

/* -------------------------------------
   REALTIME LISTENERS (FINAL FIXED)
-------------------------------------- */
function subscribeRealtime() {

  /* üîµ MESSAGE LISTENER */
  const msgChannel = dbClient.channel(`messages:${roomId}`);

  msgChannel.on(
    'postgres_changes',
    {
      event: 'INSERT',
      schema: 'public',
      table: 'messages',
      filter: `room_id=eq.${roomId}`,
    },
    (payload) => {
      messagesCache.push(payload.new);
      if (messagesCache.length > 200)
        messagesCache = messagesCache.slice(-200);
      renderMessages(messagesCache);
    }
  );

  msgChannel.subscribe();


  /* üü£ TYPING LISTENER */
  const typingChannel = dbClient.channel(`typing:${roomId}`);

typingChannel.on(
  'postgres_changes',
  {
    event: 'UPDATE',
    schema: 'public',
    table: 'typing_status',
    filter: `room_id=eq.${roomId}`,
  },
  (payload) => {
    const t = payload.new;

    if (t.username !== username && t.typing === true) {
      typingEl.textContent = `${t.username} is typing...`;
      typingEl.classList.remove('hidden');

      clearTimeout(window.hideTyping);
      window.hideTyping = setTimeout(() => {
        typingEl.classList.add('hidden');
      }, 1500);

    } else {
      typingEl.classList.add('hidden');
    }
  }
);

typingChannel.subscribe();

}

/* -------------------------------------
   INIT
-------------------------------------- */
sendBtn.addEventListener('click', sendMessage);
msgInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendMessage();
  }
});
backBtn.addEventListener('click', () => window.history.back());

loadInitialMessages();
subscribeRealtime();
</script>

</body>
</html>
